
function sword_handler_load():
    set {-blood-blocks::*} to red glazed terracotta, netherrack, red wool, red concrete powder, nether wart block, fire coral block
    set {-blood-passables::*} to red carpet, red candle

# doesn't work if you are in creative, since it gives you an extra two entity interaction range.

on left click:
    
    cancel event
    if wrapper(player)->machine->state != {-states::play}:
        stop
    hit_entities(player, get_hit_entities(player, 4.5))

function hit_entities(attacker: player, entities: entities):
    filter {_entities::*} to match all:
        input is not a display
        input is not an interaction
        input is not {_attacker}
    loop {_entities::*}:
        continue if true = is_on_cooldown("iframes", loop-value)
        set_cooldown("iframes", 5 ticks, loop-value)
        on_hit({_attacker}, loop-value)
        change_tickrate({_attacker}, 0, true)
        change_tickrate(loop-value, 0, true)
        play sound "entity.player.attack.strong" at volume 0.3 at pitch 1.2 + rnd(0.1) to {_attacker}
        wait (2 tick if loop-counter = 1 else 1 tick)
        change_tickrate({_attacker}, 20, false)
        change_tickrate(loop-value, 20, false)
        play sound "block.note_block.bell" at volume 0.3 at pitch (0.4 + (loop-counter / 5) + rnd(0.1)) to {_attacker}
        play sound "block.note_block.bass" at volume 0.3 at pitch (0.3 + (loop-counter / 5) + rnd(0.1)) to {_attacker}
        wait 1 tick if loop-counter > 3

function on_hit(attacker: player, entity: entity):
    
    draw 10 crit at {_entity} ~ y(1)
    draw 5 effect using particleSpell(red, 1) at ({_entity} ~ y(1)) with offset vec(0.3) with extra 0.2
    draw 5 dust using dustOption(red, 1) at ({_entity} ~ y(1)) with offset vec(0.3) with extra 0.2
    set {_velocity} to (normalized vector from {_attacker} to {_entity}) * 0.6
    set velocity of {_entity} to (velocity of {_entity} * 0.05)
    on_damage({_attacker}, {_entity}, 5 + rnd(1))
    
    set y of {_velocity} to 0.2
    set velocity of {_entity} to {_velocity}

function on_damage(attacker: player, entity: entity, damage: number):
    set {_is_critical} to whether fall distance of {_attacker} > 0 
    if {_is_critical} = true:
        
        play sound "entity.player.attack.crit" at volume 0.3 at pitch 1.2 to {_attacker}
        draw 50 electric_spark at {_entity} ~ y(1.5)
        add 3 + rnd(2) to {_damage}
    
    spawn_damage_indicator(flatten(head of {_entity}), {_damage}, {_is_critical})
    spawn_blood({_entity}, {_damage})
    play sound "block.sweet_berry_bush.pick_berries" at volume 0.1 at pitch 0.2 + rnd(0.1) to {_attacker}
    damage {_entity} by {_damage}
    play hurt animation on {_entity}
    
    if {_entity} is a player:
        if {_entity}'s health - {_damage} < 0:
            trigger_event(wrapper({_entity})->machine, "spectate")
            wait 5 seconds
            trigger_event(wrapper({_entity})->machine, "respawn")
    set ({_entity}'s health) to ({_entity}'s health - {_damage})
    


function spawn_blood(entity: entity, damage: number):
    draw 10 block using red glazed terracotta at ({_entity} ~ y(1)) with offset vec(0.6) with extra {_damage}
    set {_blocks::*} to (first 10 elements of shuffled blocks in radius 3 around head of {_entity}) where [input != air]
    loop {_blocks::*}:
        if loop-value is passable:
            if block below loop-value is solid:
                make (all players) see loop-value as any of {-blood-passables::*}
        else:
            make (all players) see loop-value as any of {-blood-blocks::*}
        wait 1 tick
    wait 120 seconds
    make (all players) see {_blocks::*} as normal

function with_zeros(number: number, zeros: integer) :: string:
    if {_number} = floor({_number}):
        return join ("%{_number}%.", ("0" repeated {_zeros} times))
    return "%{_number}%"

function spawn_damage_indicator(entity_head: location, damage: number, is_critical: boolean):
    set {_free_area} to {_entity_head} ~ random vector
    set {_indicator} to a_text_display()
    set billboard of {_indicator} to center
    set color of {_indicator} to rgb(0,0,0,0)
    force {_indicator} to be visible through walls
    add drop shadow to {_indicator}'s text
    set {_mid} to "#fff000" if {_is_critical} = true else "#ff7f5e"
    set {_damage_text} to with_zeros(round({_damage}, 1), 1)
    set {_count} to 20
    loop {_count} times:
        set {_percent} to loop-value / {_count}
        teleport({_indicator}, {_free_area})
        set {_easing} to ease_in_out_circle({_percent})
        set {_scale} to vec({_easing} + 0.5) * 1.6
        set {_component} to (minimessage from "<transition:%{_mid}%:%{_mid}%:#ffffff:%{_mid}%:%{_mid}%:%{_easing}%>%{_damage_text}%</transition>")
        set interpolation duration of {_displays::*} to 1 tick
        set interpolation delay of {_displays::*} to 0 ticks
        set display scale of {_indicator} to {_scale}
        if {_percent} > 0.6:
            set opacity of {_indicator} to 128 - 255 * (1 / {_easing})
        {_indicator}.text({_component}.getComponent())
        
        wait 1 tick
    
    kill {_indicator}
    a_star({_free_area}, 3, 5, {_mid})

function get_hit_entities(attacker: player, distance: number = 4, entities: entities = {_}) :: entities:
    # find range
    set {_ray} to (ray trace from {_attacker} with max distance {_distance} with ray size 0.3 while ignoring passable blocks while ignoring (displays, interactions, {_entities::*}))
    set {_entity} to raytrace hit entity of {_ray}
    return {_entities::*} if {_entity} is not set
    remove (distance between {_attacker} and {_entity}) from {_distance}
    return get_hit_entities({_attacker}, {_distance}, ({_entities::*}, {_entity}))