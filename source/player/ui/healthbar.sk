using reflection
using for loops

struct HealthBar:
    player: player
    bar: UIBar struct

    display: display

function load_health_bar():
    save_component("health_full", colored_component("♮", rgb(236, 71, 93)))
    save_component("health_empty", colored_component("♮", rgb(47, 47, 68)))

function a_health_bar() :: HealthBar struct:
    set {_health_bar} to HealthBar struct instance

    set {_display} to a_text_display()
    set {_translation} to y(0.3)

    # point display hitbox pointer down
    set pitch of {_display} to 90
    rotate ({_display}, {_translation}) around x-axis by -90

    set transformation translation of {_display} to {_translation}

    set billboard of {_display} to vertical

    set color of {_display} to rgb(0, 0, 0, 0)
    apply drop shadow to {_display}
    set {_health_bar}->display to {_display}

    set {_health_bar}->bar to a_ui_bar(5, 10, {_health_bar}, (function "display", function "actionbar"))
    return {_health_bar}

function attach_health_bar(player: player, health_bar: HealthBar struct):
    set wrapper({_player})->health_bar to {_health_bar}
    set {_health_bar}->player to {_player}
    make {_health_bar}->display ride {_health_bar}->player
    render_ui_bar({_health_bar}->bar)

function detach_health_bar(wrapper: PlayerWrapper struct):
    kill {_wrapper}->health_bar->display
    delete {_wrapper}->health_bar

function render_health_bar(health_bar: HealthBar struct, progress: number) :: textcomponent:

    set {_value_bindable} to {_health_bar}->bar->value
    set {_value} to lerp_bindable({_value_bindable}, {_progress})
    set {_limit} to lerp_bindable({_health_bar}->bar->limit, {_progress})

    set {_amount_taken} to (difference between {_value_bindable}->previous and {_value_bindable}->value) / {_health_bar}->bar->limit->value

    set {_health} to component_from_id("health_full")
    set {_color} to color format of {_health}
    
    set {_flash} to flash_color({_color}, white, {_amount_taken})
    set color format of {_health} to flash_color({_color}, {_flash}, sin({_progress} * pi radians))

    set {_bar} to a_notch_bar({_health}, component_from_id("health_empty"), {_limit}, {_value})
    set underline format of {_bar} to true
    return {_bar}

local function display(health_bar: HealthBar struct):
    for {_i} in 10 times:
        set component text of {_health_bar}->display to render_health_bar({_health_bar}, ease_in_out_circle({_i} / 10))
        wait 1 tick

local function actionbar(health_bar: HealthBar struct):
    for {_i} in 10 times:
        set wrapper({_health_bar}->player)->actionbar to render_health_bar({_health_bar}, ease_in_out_cubic({_i} / 10))
        wait 1 tick