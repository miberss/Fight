import:
    java.util.HashMap

struct Item:
    uuid: string
    owner: player
    slot: integer
    const stat_data: javaobject = new HashMap()
    const special_effect: javaobject = new HashMap()
    rank: object
    consume_animation: string
    swing_animation: string

struct StatData:
    id: string
    item: Item struct
    bindable: object
    real_line_depth: integer
    indent: integer = 2
    type: struct

struct Writing:
    components: textcomponents
    real_line_depth: integer
    line_depth: integer

struct Stat:
    const id: string
    const update: function
    const add: function
    const remove: function
    const tick: function
    const line_depth: integer
    const default_value: object

struct Ratio:
    limit: object

struct Entity:
    entity: entity

using for loops
using script reflection

function load_stats():
    for {_script} in scripts in "source/stats":
        set {_tick} to function "tick" in script "%{_script}%"
        set {-stat::%name of {_script}%} to Stat struct instance:
            id: name of {_script}
            update: function "update" in script "%{_script}%"
            add: function "add" in script "%{_script}%"
            remove: function "remove" in script "%{_script}%"
            tick: {_tick}
            line_depth: loop-counter
            default_value: 0
        run function "load" in script "%{_script}%"
    broadcast "loaded stats %indexes of {-stat::*}%"

struct StatFieldBuilder:
    const emoji: string
    const name: string
    const color: color
    const extra: number = 0

function a_stat_field(builder: StatFieldBuilder struct) :: textcomponent:
    return colored_component(merge components ((minimessage from {_builder}->emoji, px({_builder}->extra + 3), minimessage from {_builder}->name, component(":"))), {_builder}->color)

function a_filled_stat_field(stat_field: string, value: object) :: textcomponent:
    return merge components ((component_from_id("stat:%{_stat_field}%"), px(2), colored_component({_value}, rgb(240, 240, 240))))