
import:
    java.util.concurrent.atomic.AtomicInteger

options:
    gray: rgb(69, 69, 93)
    white: rgb(240, 240, 250)
    chat_white: rgb(210, 215, 220)
    spacing: px(2)
    date_format: "HH:mm"

struct Message:
    const sender: string
    const message: string
    const id: integer
    const creation: date = now
    has_header: boolean = false
    component: textcomponent
    dynamic formatted_creation: string = (this->creation formatted as {@date_format})

function load_chat():
    set {-sound::ping} to a_sound("entity.experience_orb.pickup", 0.5)
    set {-message_counter} to {-message_counter} ? new AtomicInteger(1)

on chat:
    cancel event
    chat_handle(player, message)

function format_player_header(player: player, color: color = {@white}) -> textcomponent:
    set {_head} to object text component with player head of {_player}
    set {_name} to colored_component(name of {_player}, {_color})
    return merge components px(1), {_head}, px(3), {_name}

function format_timestamp(date: date) -> textcomponent:
    return colored_component({_date} formatted as {@date_format}, {@gray})

function format_header(player: player, date: date) -> textcomponent:
    return merge components format_timestamp(now), px(4), format_player_header({_player})

function message_assemble_components(header: textcomponent, message: textcomponent, button: textcomponent = {_}, delete_button: textcomponent = {_}) -> textcomponent:
    return merge components {_header}, px(3), {_button}, px(2), component_from_id("arrow_right"), px(3), {_message}, px(2), {_delete_button}

function underlined_naughty_words(result: FilterResult struct) -> textcomponent:
    for {_text} in ({_result}->matched text):
        set {_c} to colored_component({_text}, rgb(255, 0, 0))
        set underline format of {_c} to true
        set {_component::%loop-counter%} to {_c}

    return merge components {_component::*} with " "

function chat_handle(player: player, message: string, reply_history: textcomponents = {_}):
    set {_filter_result} to filter_message({_message}, {_player}, true)

    if {_filter_result}->matched = true:
        set_actionbar_for({_player}, underlined_naughty_words({_filter_result}), 1 second)
        console_log("warn", minimessage from "%{_player}%: %{_filter_result}->matched text%")
        stop

    set {_current} to player_message_save({_player}, {_message})

    if reply_state({_player}) is set:
        reply_state_complete({_player}, {_current})
        stop

    # if last and current message are equal player and date wise, then dont send a header
    set {_header} to format_header({_player}, now)
    set {_current}->has_header to true

    set {_message_component} to colored_component({_message}, {@chat_white})

    set {_delete_button} to component_from_id("delete_button")
    create callback for {_delete_button}:
        if player is not {_player}:
            stop
        delete_message({_current}->id)

    if {_reply_history::*} is set:
        set {_button} to component_from_id("replied_button")
    else:
        set {_button} to component_from_id("reply_button")

    set hover event of {_button} to hover event showing {_reply_history::*}
    create callback for {_button}:
        # stop if player = {_player}
        reply_handle(player, {_player}, ({_reply_history::*}, message_assemble_components(format_header({_player}, now), {_message_component})))

    send_and_log(message_assemble_components({_header}, {_message_component}, {_button}, {_delete_button}), players)

local function interaction_reply_cancel(player: player):
    send actionbar component colored_component("Exited the reply", {@white}) to {_player}

local function feedback_reply_started(player: player, target: player):
    send actionbar component colored_component("Now replying to %{_target}%!, type 'exit' to stop replying", {@white}) to {_player}

local function feedback_reply_ping(player: player):
    sound({_player}, {-sound::ping})

function reply_state_start(player: player, target: player):
    set {-reply_state::%{_player}%} to a_promise(1 minute)
    feedback_reply_started({_player}, {_target})

function reply_state(player: player) -> future:
    return {-reply_state::%{_player}%} 

function reply_state_complete(player: player, message: message struct):
    complete future {-reply_state::%{_player}%} with {_message}
    delete {-reply_state::%{_player}%}

local function reply_handle(sender: player, target: player, reply_history: textcomponents):
    
    reply_state_start({_sender}, {_target})

    wait for {-reply_state::%{_sender}%} and store the result in {_message}

    if {_message} is not set:
        stop

    else if {_message}->message = "exit":
        interaction_reply_cancel({_sender})
        stop

    chat_handle({_sender}, {_message}->message, {_reply_history::*})

# get the last message sent (for comparison)
local function message_last() -> message struct:
    return 2nd last element of {-message::*}

# retrieve a message by ID
local function message_get(id: integer) -> message struct:
    return {-message::%{_id}%}

local function message_current() -> message struct:
    return {-message::%{-message_counter}.intValue()%}

# store a message and return its ID
local function player_message_save(player: player, text: string) -> message struct:
    set {_id} to {-message_counter}.incrementAndGet()
    set {-message::%{_id}%} to Message struct instance:
        message: {_text}
        sender: uuid of {_player}
        id: {_id}
    return {-message::%{_id}%}

function server_message_save(type: string):
    set {_id} to {-message_counter}.incrementAndGet()
    set {-message::%{_id}%} to Message struct instance:
        sender: {_type}
        id: {_id}

function delete_message(at: integer):
    clear_chat()
    delete {-message::%{_at}%}
    resend_chat(last 100 elements of {-message::*})

function resend_chat(messages: message structs):
    for {_message} in {_messages::*}:
        send component {_message}->component to players where [{message_blacklist::%input%::%{_message}->sender%} is not set]

function send_and_log(component: textcomponent, players: audiences):
    send component {_component} to {_players::*}
    set message_current()->component to {_component}

function clear_chat():
    send nl repeated 100 times to players
    delete {-reply_state::*}
