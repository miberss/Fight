struct SpecialEffect:
    id: string
    components: textcomponents
    line_depth: integer
    type: struct

struct SpecialEffectData:
    id: string
    item: Item struct
    special_effect: SpecialEffect struct
    components: textcomponents
    real_line_depth: integer

using for loops
using script reflection

function load_special_effects():
    for {_script} in scripts in "source/special_effects":
        set {-special_effect::%name of {_script}%} to SpecialEffect struct instance:
            id: name of {_script}
            components: result of function "create" in script "%{_script}%"
            line_depth: loop-counter
            type: result of function "add" in script "%{_script}%"

function a_effect_title(title: string, color: color) :: textcomponent:
    set {_width} to (50 - (width({_title}) / 3)) / 2
    set {_bar} to a_notch_bar(component_from_id("bar"), component_from_id("bar"), {_width}, {_width})
    return merge components {_bar}, px(4), a_angular_brackets(colored_component({_title}, {_color})), px(4), {_bar}

function a_effect_description(line: textcomponent) :: textcomponent:
    set {_component} to merge components px(5), {_line}
    set italic format of {_component} to false
    set color format of {_component} to gray
    return {_component}

function a_lore_unit(value: number, unit: string) :: textcomponent:
    return wrap_around(component_unit({_value}, {_unit}, rgb(171, 205, 239), rgb(171, 205, 239)), c("("), c(")"), 1)

function a_key(id: string) :: textcomponent:
    set {_key} to keybind component of "key.%{_id}%"
    set color format of {_key} to orange
    return wrap_around({_key}, c("["), c("]"), 0.85)