
using script reflection

struct Thunderbolt:
    name: string = "THUNDERBOLT"
    color: color = rgb(100,150,240)
    key: string = "drop"
    cooldown: timespan = 3 seconds
    radius: number = 3.5
    amount: integer = 3
    on_drop: function = function "on_drop"
    dark_particle: particle = (30 rgb(20, 60, 200) dust particle with offset vec(0.2) with extra value 0.3)
    light_particle: particle = (white dust particle that transitions to rgb(100,150,240))

local function add() -> struct:
    return Thunderbolt struct instance

local function update(thunderbolt: Thunderbolt struct) -> textcomponents:
    set {_title} to a_effect_title({_thunderbolt}->name, {_thunderbolt}->color)
    set {_key} to a_key({_thunderbolt}->key)
    set {_amount} to a_lore_unit({_thunderbolt}->amount, "x")
    set {_radius} to a_lore_unit({_thunderbolt}->radius, "m")
    set {_text::1} to a_effect_description(({_key}, " Casts thunderbolts ", {_amount}))
    set {_text::2} to a_effect_description(("that drop down and create a"))
    set {_text::3} to a_effect_description(("splash ", {_radius}))
    return {_title}, {_text::*}, blank()

local function on_drop(player: player, thunderbolt: Thunderbolt struct, weapon: Item struct):
    set {_forward} to vector in direction of {_player}
    set {_right} to {_forward} rotated around y-axis by 30
    set {_left} to {_forward} rotated around y-axis by -30
    shoot_thunderbolt({_player}, {_weapon}, {_forward}, 2.5, 4.5)
    wait 2 ticks
    shoot_thunderbolt({_player}, {_weapon}, {_right}, 1.5, 4.5)
    wait 2 ticks
    shoot_thunderbolt({_player}, {_weapon}, {_left}, 1.5, 4.5)

function shoot_thunderbolt(player: player, weapon: Item struct, direction: vector, size: number, range: number):

    set {_head} to {_player}'s head

    set {_ray} to (raytrace from {_head} along {_direction} with max distance {_range} while ignoring passable blocks)

    set {_location} to (raytrace hit block of {_ray}) ? block at ({_head} ~ {_direction} * {_range})

    set {_line} to line in direction {_direction} and length {_range}

    for {_particle} in vfx_thunder_bolt():
        set particle of {_line} to {_particle}
        draw shape {_line} at {_head}
        draw {_particle} at {_location}

    a_star({_location}, 5, 10)
    wait 1 tick

    set {_ray} to (raytrace from {_location} along y(-1) while ignoring passable blocks while ignoring all entitytypes)
    set {_line} to line from {_location} to (raytrace hit location of {_ray})

    for {_particle} in vfx_thunder_bolt():
        
        set particle of {_line} to {_particle}
        draw {_particle} at {_location}
        draw shape {_line}

    set {_component} to a_animation_component("flash", (raytrace hit block of {_ray}) ~ y(0.5), FlashOptions struct instance):
        size: {_size}

    wait for future {_component}->end and store the result in {_interaction}
    
    set {_entities::*} to ...(world of {_interaction}).getNearbyEntities({_interaction}.getBoundingBox())
    for {_entity} in {_entities::*}:

        set {_ctx} to a_attack_context({_player}, {_weapon}, ("magic", "thunderbolt", "lightning"))
        process_stats({_ctx}, "pre_hit")
        set {_ctx}->victim to {_entity}
        on_hit({_ctx})
