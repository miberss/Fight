using reflection
using for loops

function create_item(nbt: nbt) :: Item struct:
    set {_uuid} to random uuid
    set {_level} to int tag "level" of {_nbt}
    set {_rank} to string tag "rank" of {_nbt}
    set {_name} to string tag "name" of {_nbt}
    set {_sprite} to string tag "sprite" of {_nbt}

    set {_level_component} to a_level({_level})
    set {_name_component} to shadow(component(proper case {_name}), rgb(0,0,0,255))
    set {_item_name} to merge(({-rank::%{_rank}%}, sprite({_sprite}), {_name_component}, {_level_component}), px(2))

    set {-item::%{_uuid}%} to Item struct instance:
        uuid: {_uuid}
        source: {_nbt}
        base: a_blank_item(string tag "itemtype" of {_nbt}, {_item_name}, {_uuid})
        rank: {_rank}
    return {-item::%{_uuid}%}

function give_item_to(item: Item struct, player: player):
    set {_item}->owner to {_player} 
    set {_item}->slot to index of first empty slot in {_player}
    set slot {_item}->slot of {_player} to {_item}->base
    render_lore({_item})

function deserialize_stats(source: nbt) :: objects:
    set {_compound::*} to keyed (compound_as_list(compound tag "stats[0]" of {_source}))
    set {_stats::*} to {_compound::*} mapped with [a_stat(stat_type(input index), input)]
    sort {_stats::*} by input->extension->order
    return {_stats::*}

function deserialize_special_effects(source: nbt) :: objects:
    set {_compound::*} to (string list tag "special_effects" of {_source})
    return {_compound::*} mapped with [a_special_effect(special_effect_type(input))]

function add_item_to(player: player, item_id: string):
    set {_item} to create_item(read_snbt_file("plugins/Skript/scripts/resources/items/%{_item_id}%.snbt"))
    give_item_to({_item}, {_player})
