using script reflection
using for loops

function render_lore(item: Item struct, description: string, special-effects: strings, stats: objects):
    set {_order::1::1} to a_writing(a_lore({_description}))

    for {_name}, {_value} in {_stats::*}:
        set {_order::2::%loop-counter%} to rendered_stat({_name}, {_value})

    for {_special} in {_special-effects::*}:
        set {_order::3::%loop-counter%} to rendered_special_effect({_special})

    for index {_section} in (indexes of {_order::*}):
        sort {_order::%{_section}%::*} by [input->depth]
        for {_object} in {_order::%{_section}%::*}:
            set {_depth} to render_object({_object}, {_depth} + 1)
        add 1 to {_depth}

function render_object(object: struct, depth: integer) :: integer:
    set {_object}->depth to {_depth}

    switch (struct template of {_object}):
        case "statdata":
            attach_stat({_item}, {_object})
        case "writing", "special_effect":
            set {_depth} to set_lines({_item}, {_object}->components, {_depth})

    return {_depth}

function set_lines(item: Item struct, components: textcomponents, line: integer) :: integer:
    for {_component} in {_components::*}:
        set_line({_item}->owner, {_item}->slot, {_line} + loop-counter, {_component})
        add 1 to {_line}
    return {_line} - 1

function set_line(stat: StatData struct, component: textcomponent):
    set {_item} to {_stat}->item
    set_line({_stat}->owner, {_item}->slot, {_item}->depth, {_component})

function set_line(player: player, slot: integer, line: integer, component: textcomponent):
    set italic format of {_component} to false
    set color format of {_component} to white
    set line {_line} of component item lore of (slot {_slot} of {_player}) to {_component}
