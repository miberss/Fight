
struct BloodStone:
    stat: Stat struct
    limit: integer
    orbs: BloodStoneOrb structs
    orbs_to_be_broken: BloodStoneOrb structs
    rotation: number = 0
    order: integer = 10

struct BloodStoneOrb:
    display: display
    interaction: entity
    blood_stone: BloodStone struct
    pos: vector
    dynamic location: location = (this->blood_stone->stat->item->owner) ~ this->pos
    size: number
    dynamic scale: vector = vec(this->size)

local function add(stat: Stat struct) -> BloodStone struct:
    return BloodStone struct instance:
        stat: {_stat}
        limit: 8

local function a_blood_stone_orb(blood_stone: BloodStone struct) -> BloodStoneOrb struct:
    set {_item} to a_item_display()
    set item of {_item} to red_glazed_terracotta, netherrack, fire_coral_block, or nether_wart_block
    set glowing of {_item} to true
    set glowing color override of {_item} to rgb(160, 48, 48)

    set {_glass} to a_item_display()
    set item of {_glass} to red stained glass

    set {_circle} to a_text_display()
    set component text of {_circle} to component_from_id("blood_stone")
    set billboard of {_circle} to vertical
    set color of {_circle} to rgb(0,0,0,0)

    make ({_glass}, {_circle}) ride {_item}

    set {_interaction} to a_interaction()
    set {_orb} to BloodStoneOrb struct instance:
        blood_stone: {_blood_stone}
        display: {_item}
        interaction: {_interaction}

    set metadata "orb" of {_interaction} to {_orb}

    return {_orb}

local function pulse(orb: BloodStoneOrb struct):
    set {_displays::*} to {_orb}->display, ({_orb}->display's passengers)
    loop 30 times:
        set {_easing} to ease_in_out_elastic(loop-counter / 30)
        set {_orb}->size to ({_easing} + 0.5) * 0.4
        interpolate({_displays::*})
        set display scale of {_displays::1} to {_orb}->scale
        set display scale of {_displays::2} to {_orb}->scale * 1.2
        set display scale of {_displays::3} to {_orb}->scale * 5
        set transformation translation of {_displays::3} to y(y of {_orb}->scale / -2 + 0.5)
        rotate {_displays::1}, {_displays::2} around y-axis by 10 * {_easing}
        set interaction scale of {_orb}->interaction to {_orb}->scale
        wait 1 tick

local function dust(orb: BloodStoneOrb struct, n: integer = 10):
    # draw {_n} dust using dustOption(rgb(160, 48, 48), 1.4) at ({_orb}->location ~ random vector / 5) with offset (random vector) with extra 0.05

local function dust_t(orb: BloodStoneOrb struct, n: integer = 10):
    # draw {_n} dust_color_transition using dustTransition(rgb(160, 48, 48), rgb(250, 250, 50), 1.1) at ({_orb}->location ~ random vector / 5) with offset (random vector) with extra 0.05

local function tick_orb(orb: BloodStoneOrb struct):
    set {_location} to {_orb}->location
    set yaw of {_location} to 0
    set pitch of {_location} to 0
    teleport({_orb}->display, {_location})
    teleport({_orb}->interaction, {_location} ~ y({_orb}->size / -2))
    if chance of 1%:
        pulse({_orb})
    else if chance of 5%:
        dust({_orb})
    else if chance of 2%:
        dust_t({_orb})
    block at {_location} ~ y(1) is air
    make players see {_location} ~ y(1) as light[level=5]
    wait 10 ticks
    make players see {_location} ~ y(1) as normal

local function add_orb(orb: BloodStoneOrb struct):
    add {_orb} to {_orb}->blood_stone->orbs
    pulse({_orb})
    dust_t({_orb}, 20)

local function break_orb(orb: BloodStoneOrb struct):
    remove {_orb} from {_orb}->blood_stone->orbs
    set {_displays::*} to {_orb}->display, ({_orb}->display's passengers)
    loop 10 times:
        set {_easing} to ease_out_bounce(loop-counter / 10)
        set {_orb}->size to ({_easing} + 0.5) * 1
        set interpolation duration of {_displays::*} to 1 tick
        set interpolation delay of {_displays::*} to 0 ticks
        set display scale of {_displays::1} to {_orb}->scale
        set display scale of {_displays::2} to {_orb}->scale * 1.2
        set display scale of {_displays::3} to {_orb}->scale * 5
        set transformation translation of {_displays::3} to y(y of {_orb}->scale / -2 + 0.5)
        rotate {_displays::1}, {_displays::2} around y-axis by 10 * {_easing}
        set interaction scale of {_orb}->interaction to {_orb}->scale
        wait 1 tick
    dust({_orb}, 50)
    dust_t({_orb}, 20)
    kill {_orb}->interaction, {_orb}->display, ({_orb}->display's passengers)
    delete {_orb}

local function update(bindable: Bindable struct, stat: Stat struct) -> textcomponent:
    set {_blood_stone} to {_stat}->extension
    bind_set_silently({_bindable}, clamp({_bindable}->value, 0, {_blood_stone}->limit))
    set {_value} to {_bindable}->value
    if {_value} = ({_bindable}->previous ? 0):
        stop
    run 0 tick later:
        if {_value} > {_bindable}->previous:
            loop ({_value} - {_bindable}->previous) times:
                add_orb(a_blood_stone_orb({_blood_stone}))
                wait 3 ticks
        else:
            loop ({_bindable}->previous - {_value}) times:
                break_orb(random element of {_blood_stone}->orbs)

    return a_notch_bar(component_from_id("blood_stone"), component_from_id("unfilled_blood_stone"), {_stat}->extension->limit, {_bindable}->value)

local function tick(stat: Stat struct):
    set {_blood_stone} to {_stat}->extension
    set {_point_count} to max({_stat}->current, 5)
    set {_angle} to 360 / {_point_count}
    set {_tip} to x(({_stat}->current / {_blood_stone}->limit) + 2) + y(1)
    for {_orb} in {_blood_stone}->orbs:
        set {_rotated_tip} to {_tip}
        rotate {_rotated_tip} around y-axis by {_blood_stone}->rotation
        set {_ripple} to y(sin(((loop-counter * {_point_count} * 6) + (({_blood_stone}->rotation + loop-counter) * 6))) / 2)
        set {_orb}->pos to {_rotated_tip} + {_ripple}
        rotate {_tip} around y-axis by {_angle}
        tick_orb({_orb})
    add 1 to {_blood_stone}->rotation

local function remove(stat: Stat struct):
    loop {_stat}->extension->orbs:
        break_orb(loop-value)
