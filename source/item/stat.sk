struct StatType:
    const id: string
    const update: function
    const add: function
    const remove: function
    const tick: function
    const line_depth: integer

struct Stat:
    id: string
    item: Item struct
    bindable: object
    depth: integer
    indent: integer = 2
    render: textcomponents
    type: struct

struct Ratio:
    limit: object

using for loops
using script reflection

function load_stat_types():
    for {_script} in scripts in "source/item/stats/":
        set {-stat-type::%name of {_script}%} to StatType struct instance:
            id: name of {_script}
            update: function "update" in script "%{_script}%"
            add: function "add" in script "%{_script}%"
            remove: function "remove" in script "%{_script}%"
            tick: function "tick" in script "%{_script}%"
            line_depth: loop-counter
        run function "load" in script "%{_script}%"

function stat_type(id: string) :: StatType struct:
    return {-stat-type::%{_id}%}

function stat_of(item: Item struct, stat-type: string) :: object:
    if {_item}->stats.containsKey({_stat-type}) = false:
        throw runtime error "Tried to get value of %{_stat-type}% on %{_item}->uuid%, but failed as there isn't that stat on the item"
        stop
    return {_item}->stats.get({_stat-type})

function bindable_stat_of(item: Item struct, stat-type: string) :: Bindable struct:
    return stat_of({_item}, {_stat-type})->bindable

function set_stat(item: Item struct, stat-type: string, value: object):
    set bindable_stat_of({_item}, {_stat-type})'s value to {_value}

function attach_stat(item: Item struct, stat: Stat struct):
    set {_stat}->item to {_item}
    {_item}->stats.put({_stat}->id, {_stat})
    trigger_update({_stat}->bindable, {_stat}->bindable's value)

function rendered_stat(id: string, value: object) :: Stat struct:
    set {_stat} to Stat struct instance:
        id: {_id}
    
    set {_stat-type} to stat_type({_id})

    if {_stat-type}->add is set:
        set {_stat}->type to result of {_stat-type}->add with args {_stat}

    set {_renderer} to a_stat_lore_renderer({_stat}, {_stat-type})
    set {_stat}->bindable to bindable with {_value} using callback {_renderer}
    return {_stat}

function a_stat_lore_renderer(stat: Stat struct, stat-type: StatType struct) :: section:

    set {_item} to {_stat}->item
    set {_stat-update} to {_stat-type}->update
    set {_indent} to px({_stat}->indent)

    create section with {_bindable}, {_value} stored in {_lore-renderer}:
        
        set {_stat-component} to result of {_stat-update} with args {_bindable}, {_stat}
        set {_render} to merge components ({_indent}, {_stat-component})
        set_line({_stat}, {_render})
        set {_stat}->render to {_render}

    return {_lore-renderer}

function execute_stat_ticker(stat: Stat struct):
    set {_id} to {_stat}->id
    if stat_type({_id})->tick is not set:
        stop

    run 0 tick later repeating every 1 tick:
        exit loop if item_of({_stat}) is not set
        run stat_type({_id})->tick with args {_stat}
